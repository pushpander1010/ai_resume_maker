            "auth_uri": "https://accounts.google.com/o/oauth2/v2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "redirect_uris": [redirect_uri],
            "javascript_origins": [redirect_uri.rstrip("/")],
        }
    }

    flow = Flow.from_client_config(client_config, scopes=scopes)
    flow.redirect_uri = redirect_uri

    # ---- Callback: exchange code -> tokens (once)
    if code and not st.session_state.oauth_code_exchanged:
        query = urllib.parse.urlencode(
            {k: (v[0] if isinstance(v, list) else v) for k, v in qp.items()},
            doseq=True
        )
        authorization_response = f"{redirect_uri}?{query}"
        try:
            flow.fetch_token(authorization_response=authorization_response)
        except InvalidGrantError:
            # code used/expired: reset, start over
            _clear_query_params()
            st.session_state.oauth_code_exchanged = False
            auth_url, _ = flow.authorization_url(
                access_type="offline",
                include_granted_scopes="true",
                prompt="consent select_account",
            )
            st.link_button("Continue with Google", auth_url)
            st.stop()
        except Exception as e:
            st.error(
                "Failed to fetch token. Ensure this exact redirect URI "
                f"is in your OAuth client:\n{redirect_uri}\n\nDetails: {e}"
            )
            _clear_query_params()
            st.stop()

        creds = flow.credentials
        # Save creds for THIS user (identified by id_token.sub)
        try:
            _save_creds_for_user(creds, client_id)
        except Exception as e:
            st.error(f"Could not save user token: {e}")
            _clear_query_params()
            st.stop()

        st.session_state.oauth_code_exchanged = True
        _clear_query_params()
        st.rerun()

    # If we have code but already exchanged it, wait for rerun to clean URL
    if code and st.session_state.oauth_code_exchanged:
        st.stop()

    # ---- Start OAuth (same tab)  force account chooser
    auth_url, _ = flow.authorization_url(
        access_type="offline",
        include_granted_scopes="true",
        prompt="consent select_account",
    )
    st.link_button("Continue with Google", auth_url)
    st.stop()

def get_model_instance(model_key):
    if not isinstance(model_key, str):
        return model_key
    if model_key.startswith("google|"):
        model_id = model_key.split("|")[1]
        return GoogleGenerativeAI(model=model_id, temperature=0.7)
    elif model_key.startswith("groq|"):
        model_id = model_key.split("|")[1]
        return ChatGroq(model=model_id, temperature=0.7)
    elif model_key.startswith("perplexity|"):
        model_id = model_key.split("|")[1]
        return ChatPerplexity(model=model_id, temperature=0.7)
    else:
        raise ValueError(f"Unknown model: {model_key}")

def passthrough(state:ModelState)->ModelState:
    return state

def write_email(state: ModelState) -> ModelState:
    print("writing email")
    parser = PydanticOutputParser(pydantic_object=GmailMessage)
    prompt = PromptTemplate(
        template=(
            "You are an expert email drafter, known for your ability to draft professional emails.\n\n"
            "Given candidate details:\n{candidate_details}\n\n"
            "Draft a professional email based on the job description:\n{jd}\n\n"
            "Required fields:\n"
            "  `to`: string\n"
            "  `subject`: string\n"
            "  `body`: string\n\n"
            "Return the output in STRICT format:\n{template}"
        ),
        input_variables=["candidate_details", "jd"],
        partial_variables={"template": parser.get_format_instructions()},
    )
    chain = prompt | get_model_instance(model_key=state.model) | parser
    output = chain.invoke({"candidate_details": state.candidate_details, "jd": state.jd})
    return {"gmail_message": output}


def convert_docx_to_pdf(state: ModelState) -> ModelState:
    """
    Converts DOCX -> PDF via Google Drive:
      1) Ensures OAuth ONCE with combined scopes (Drive+Gmail).
      2) Uploads DOCX as Google Doc.
      3) Exports to PDF and downloads.
      4) Returns pdf_file and saves creds for later Gmail usage.
    """
    if not state.docx_file or not os.path.exists(state.docx_file):
        return {"pdf_file": None}

    SCOPES = [
        "https://www.googleapis.com/auth/drive.file",
        "https://www.googleapis.com/auth/drive.metadata.readonly",
        "https://www.googleapis.com/auth/gmail.send",
        "https://www.googleapis.com/auth/gmail.compose",
        "https://www.googleapis.com/auth/gmail.readonly",
    ]

    # --- Save intent BEFORE auth (so we can resume after redirect) ---
    st.session_state.oauth_pending_action = "convert_docx_to_pdf"
    st.session_state.oauth_payload = {"docx_file": state.docx_file}

    creds = state.gmail_auth_creds or ensure_google_creds(SCOPES)
    # If we got creds immediately (cached/refresh), we wont leave the page.
    # If we had to redirect, well return here after st.rerun().

    # Resume only once
    if st.session_state.oauth_pending_action == "convert_docx_to_pdf":
        # clear the pending marker so we don't loop
        st.session_state.oauth_pending_action = None
        payload = st.session_state.oauth_payload or {}
        st.session_state.oauth_payload = {}

        input_path = payload.get("docx_file") or state.docx_file
        base, _ = os.path.splitext(input_path)
        output_path = f"{base}.pdf"

        drive = build("drive", "v3", credentials=creds)

        # 1) Upload DOCX as Google Doc
        file_metadata = {
            "name": os.path.basename(input_path),
            "mimeType": "application/vnd.google-apps.document",
        }
        media = MediaFileUpload(
            input_path,
            mimetype="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            resumable=True,
        )
        uploaded = drive.files().create(
            body=file_metadata, media_body=media, fields="id"
        ).execute()
        file_id = uploaded["id"]

        try:
            # 2) Export Google Doc to PDF
            request = drive.files().export_media(fileId=file_id, mimeType="application/pdf")
            fh = io.BytesIO()
            downloader = MediaIoBaseDownload(fh, request)
            done = False
            while not done:
                _, done = downloader.next_chunk()

            # 3) Save PDF
            with open(output_path, "wb") as f:
                f.write(fh.getvalue())

            # 4) Expose creds for downstream Gmail step
            return {"pdf_file": output_path, "gmail_auth_creds": creds}

        finally:
            # Cleanup temp Google Doc
            try:
                drive.files().delete(fileId=file_id).execute()
            except Exception:
                pass

    # If for some reason we're between legs
    return {}

def create_draft_with_gmail_auth(state: ModelState) -> ModelState:
    """
    Reuses OAuth creds (set during DOCX->PDF conversion).
    If not present, ensures creds silently via the same helper.
    Creates a Gmail draft with optional PDF attachment.
    """
    import os, base64, mimetypes
    from email.message import EmailMessage
    from googleapiclient.discovery import build

    # Reuse creds from state if available; else ensure them (no popup if token.pickle exists)
    SCOPES = [
        "https://www.googleapis.com/auth/gmail.send",
        "https://www.googleapis.com/auth/gmail.compose",
        "https://www.googleapis.com/auth/gmail.readonly",
    ]
    creds = state.gmail_auth_creds or ensure_google_creds(SCOPES)

    service = build("gmail", "v1", credentials=creds)

    # Compose email
    msg = EmailMessage()
    body = (state.gmail_message.body if state.gmail_message else None) or "Default message body"
    msg.set_content(body)

    profile = service.users().getProfile(userId="me").execute()
    from_addr = profile["emailAddress"]

    to_addr = (state.gmail_message.to if state.gmail_message and state.gmail_message.to else "example@example.com")
    subject = (state.gmail_message.subject if state.gmail_message and state.gmail_message.subject else "AI Test")

    msg["To"] = to_addr
    msg["From"] = from_addr
    msg["Subject"] = subject

    # Attach PDF if present
    if state.pdf_file and os.path.exists(state.pdf_file):
        ctype, _ = mimetypes.guess_type(state.pdf_file)
        main, sub = (ctype.split("/", 1) if ctype else ("application", "octet-stream"))
        with open(state.pdf_file, "rb") as f:
            msg.add_attachment(f.read(), maintype=main, subtype=sub, filename=os.path.basename(state.pdf_file))

    # Create draft
    raw = base64.urlsafe_b64encode(msg.as_bytes()).decode()
    draft = service.users().drafts().create(userId="me", body={"message": {"raw": raw}}).execute()
    print(f"âœ… Draft created: ID = {draft['id']}")

    # Persist creds on state
    return {"gmail_auth_creds": creds}


def get_jd(state:ModelState)->ModelState:
    print("Getting JD")
    "Gets JD from the user"
    if state.jd and state.jd.raw_jd:
        return state
    jd_text=input("Enter the job description.")
    if len(jd_text)>0:
        jd=JD.model_construct(raw_jd=jd_text)
        return {"jd":jd}
    return {"jd":None}

def jd_provided(state:ModelState)->bool:
    return state.jd is not None

